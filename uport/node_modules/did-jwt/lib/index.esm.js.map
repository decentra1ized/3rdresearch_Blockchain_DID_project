{"version":3,"file":"index.esm.js","sources":["../src/Digest.ts","../src/SimpleSigner.ts","../src/util.ts","../src/EllipticSigner.ts","../src/NaclSigner.ts","../src/VerifierAlgorithm.ts","../src/SignerAlgorithm.ts","../src/JWT.ts"],"sourcesContent":["import { sha256 as sha256js, Message } from 'js-sha256'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\nimport { Buffer } from 'buffer'\n\nexport function sha256(payload: Message): Buffer {\n  return Buffer.from(sha256js.arrayBuffer(payload))\n}\n\nexport function keccak(data: Message): Buffer {\n  return Buffer.from(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  return `0x${keccak(Buffer.from(hexPublicKey.slice(2), 'hex'))\n    .slice(-20)\n    .toString('hex')}`\n}\n","import { ec as EC, ec } from 'elliptic'\nimport { sha256 } from './Digest'\nimport { Signer } from './JWT'\n\nconst secp256k1: EC = new EC('secp256k1')\n\nfunction leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n/**\n *  The SimpleSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  if (hexPrivateKey.startsWith('0x')) {\n    hexPrivateKey = hexPrivateKey.substring(2)\n  }\n  const privateKey: ec.KeyPair = secp256k1.keyFromPrivate(hexPrivateKey)\n  return async data => {\n    const { r, s, recoveryParam }: EC.Signature = privateKey.sign(sha256(data))\n    return {\n      r: leftpad(r.toString('hex')),\n      s: leftpad(s.toString('hex')),\n      recoveryParam\n    }\n  }\n}\n\nexport default SimpleSigner\n","import { EcdsaSignature } from './JWT'\nimport base64url from 'uport-base64url'\n\nexport function base64ToBytes(s: string): Uint8Array {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0))\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return Buffer.from(b).toString('base64')\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose: Buffer = Buffer.alloc(recoverable ? 65 : 64)\n  Buffer.from(r, 'hex').copy(jose, 0)\n  Buffer.from(s, 'hex').copy(jose, 32)\n  if (recoverable) {\n    if (recoveryParam === undefined) {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = recoveryParam\n  }\n  return base64url.encode(jose)\n}\n","import { EcdsaSignature } from './JWT'\nimport SimpleSigner from './SimpleSigner'\nimport { toJose } from './util'\n\ntype Signer = (data: string) => Promise<string>\n// we know that we always get a EcdsaSignature from Simplesigner\nconst isEcdsaSig = (obj: any): obj is EcdsaSignature => true\n\n/**\n *  The EllipticSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  const signer = SimpleSigner(hexPrivateKey)\n  return async data => {\n    const signature: EcdsaSignature | string = await signer(data)\n    if (isEcdsaSig(signature)) {\n      return toJose(signature)\n    }\n  }\n}\n\nexport default EllipticSigner\n","import { sign } from '@stablelib/ed25519'\nimport { encode } from '@stablelib/utf8'\nimport { Buffer } from 'buffer'\nimport { Signer } from './JWT'\nimport { base64ToBytes } from './util'\nimport base64url from 'uport-base64url'\n\n/**\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  const privateKey: Uint8Array = base64ToBytes(base64PrivateKey)\n  return async data => {\n    const dataBytes: Uint8Array = encode(data)\n    const sig: Uint8Array = sign(privateKey, dataBytes)\n    const b64UrlSig: string = base64url.encode(Buffer.from(sig))\n    return b64UrlSig\n  }\n}\n\nexport default NaclSigner\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport base64url from 'uport-base64url'\nimport { verify } from '@stablelib/ed25519'\nimport { EcdsaSignature } from './JWT'\nimport { PublicKey } from 'did-resolver'\nimport { encode } from '@stablelib/utf8'\nimport { base64ToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawsig: Buffer = base64url.toBuffer(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = rawsig.slice(0, 32).toString('hex')\n  const s: string = rawsig.slice(32, 64).toString('hex')\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\nexport function verifyES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const hash: Buffer = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ publicKeyHex }) => {\n    return typeof publicKeyHex !== 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress }) => {\n    return typeof ethereumAddress !== 'undefined'\n  })\n\n  let signer: PublicKey = fullPublicKeys.find(({ publicKeyHex }) => {\n    try {\n      return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [\n      { ...so, recoveryParam: 0 },\n      { ...so, recoveryParam: 1 }\n    ]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): PublicKey => {\n    const hash: Buffer = sha256(data)\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: PublicKey = authenticators.find(\n      ({ publicKeyHex, ethereumAddress }) =>\n        publicKeyHex === recoveredPublicKeyHex ||\n        publicKeyHex === recoveredCompressedPublicKeyHex ||\n        ethereumAddress === recoveredAddress\n    )\n\n    return signer\n  }\n\n  const signer: PublicKey[] = signatures.map(checkSignatureAgainstSigner).filter(key => key != null)\n\n  if (signer.length === 0) throw new Error('Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const clear: Uint8Array = encode(data)\n  const sig: Uint8Array = base64ToBytes(base64url.toBase64(signature))\n  const signer: PublicKey = authenticators.find(({ publicKeyBase64 }) =>\n    verify(base64ToBytes(publicKeyBase64), clear, sig)\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: PublicKey[]) => PublicKey\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  Ed25519: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import { Buffer } from 'buffer'\nimport { Signer, EcdsaSignature, SignerAlgorithm } from './JWT'\nimport { toJose } from './util'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSigner(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable) throw new Error('ES256K-R not supported when signer function returns string')\n      return signature\n    }\n  }\n}\n\nexport function Ed25519Signer(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSigner(),\n  'ES256K-R': ES256KSigner(true),\n  Ed25519: Ed25519Signer()\n}\n\nfunction SignerAlgorithm(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlgorithm\n","import VerifierAlgorithm from './VerifierAlgorithm'\nimport SignerAlgorithm from './SignerAlgorithm'\nimport base64url from 'uport-base64url'\nimport { DIDDocument, PublicKey } from 'did-resolver'\n\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport type Signer = (data: string) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  alg?: string\n  expiresIn?: number\n}\n\nexport interface Resolvable {\n  resolve: (did: string) => Promise<DIDDocument | null>\n}\n\nexport interface JWTVerifyOptions {\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n}\n\nexport interface DIDAuthenticator {\n  authenticators: PublicKey[]\n  issuer: string\n  doc: DIDDocument\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  type?: string\n  exp?: number\n  rexp?: number\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\nexport interface JWTVerified {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: object\n  jwt: string\n}\n\nexport interface PublicKeyTypes {\n  [name: string]: string[]\n}\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  Ed25519: ['ED25519SignatureVerification']\n}\n\nconst defaultAlg = 'ES256K'\n\nfunction encodeSection(data: any): string {\n  return base64url.encode(JSON.stringify(data))\n}\n\nexport const NBF_SKEW: number = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts: RegExpMatchArray = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(base64url.decode(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWS')\n}\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(base64url.decode(jws.payload)) })\n    return decodedJwt\n  } catch(e) {\n    throw new Error('Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {SimpleSigner}      signer            a signer, reference our SimpleSigner.js\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\n */\nexport async function createJWS(payload: string | any, signer: Signer, header: Partial<JWTHeader> = {}): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload)\n  const signingInput: string = [encodeSection(header), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlgorithm(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload            payload object\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg         [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K.\n *                                                    Please use `header.alg` to specify the algorithm\n *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js\n *  @param    {Object}            header             optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: any,\n  { issuer, signer, alg, expiresIn }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header)\n}\n\nfunction verifyJWSDecoded({ header, data, signature }: JWSDecoded, pubkeys: PublicKey | PublicKey[]): PublicKey {\n  if (!Array.isArray(pubkeys)) pubkeys = [pubkeys]\n  const signer: PublicKey = VerifierAlgorithm(header.alg)(data, signature, pubkeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubkeys` match.\n *\n *  @example\n *  const pubkey = verifyJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<PublicKey> | PublicKey}    pubkeys     The public keys used to verify the JWS\n *  @return   {PublicKey}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubkeys: PublicKey | PublicKey[]): PublicKey {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubkeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: null,\n    auth: null,\n    audience: null,\n    callbackUrl: null\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const { doc, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    payload.iss,\n    options.auth\n  )\n  const signer: PublicKey = await verifyJWSDecoded({ header, data, signature } as JWSDecoded, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  if (signer) {\n    const nowSkewed = now + NBF_SKEW\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - NBF_SKEW) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find(item => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, doc, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  auth?: boolean\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  const doc: DIDDocument = await resolver.resolve(issuer)\n  if (!doc) throw new Error(`Unable to resolve DID document for ${issuer}`)\n  // is there some way to have authenticationKeys be a single type?\n  const authenticationKeys: boolean | string[] = auth\n    ? (doc.authentication || []).map(({ publicKey }) => publicKey)\n    : true\n  const authenticators: PublicKey[] = (doc.publicKey || []).filter(({ type, id }) =>\n    types.find(\n      supported =>\n        supported === type && (!auth || (Array.isArray(authenticationKeys) && authenticationKeys.indexOf(id) >= 0))\n    )\n  )\n\n  if (auth && (!authenticators || authenticators.length === 0)) {\n    throw new Error(`DID document for ${issuer} does not have public keys suitable for authenticationg user`)\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, doc }\n}\n"],"names":["sha256","payload","Buffer","from","sha256js","arrayBuffer","toEthereumAddress","hexPublicKey","data","slice","keccak_256","toString","secp256k1","EC","leftpad","size","length","repeat","SimpleSigner","hexPrivateKey","startsWith","substring","privateKey","keyFromPrivate","sign","s","recoveryParam","r","base64ToBytes","Uint8Array","Array","prototype","call","toJose","recoverable","jose","alloc","copy","undefined","Error","base64url","encode","EllipticSigner","signer","signature","NaclSigner","base64PrivateKey","dataBytes","sig","b64UrlSig","toSignatureObject","rawsig","toBuffer","sigObj","verifyRecoverableES256K","authenticators","signatures","so","map","hash","recoveredKey","recoverPubKey","recoveredPublicKeyHex","recoveredCompressedPublicKeyHex","recoveredAddress","find","publicKeyHex","ethereumAddress","filter","key","algorithms","ES256K","fullPublicKeys","ethAddressKeys","keyFromPublic","verify","err","ES256K-R","Ed25519","clear","toBase64","publicKeyBase64","VerifierAlgorithm","alg","impl","instanceOfEcdsaSignature","object","ES256KSigner","verifyJWT","jwt","options","resolver","auth","audience","callbackUrl","decodeJWT","header","issuer","types","SUPPORTED_PUBLIC_KEY_TYPES","resolve","doc","authenticationKeys","authentication","publicKey","type","id","supported","isArray","indexOf","resolveAuthenticator","iss","verifyJWSDecoded","now","Math","floor","Date","nowSkewed","NBF_SKEW","nbf","iat","exp","aud","item","createJWT","expiresIn","typ","timestamps","fullPayload","createJWS","defaultAlg","encodedPayload","encodeSection","signingInput","join","jwtSigner","SignerAlgorithm","JSON","stringify","decodeJWS","jws","parts","match","parse","decode","Object","assign","e","pubkeys","verifyJWS"],"mappings":"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"}