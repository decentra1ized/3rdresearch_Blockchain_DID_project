{"version":3,"file":"index.js","sources":["../src/Digest.ts","../src/SimpleSigner.ts","../src/util.ts","../src/VerifierAlgorithm.ts","../src/SignerAlgorithm.ts","../src/JWT.ts","../src/EllipticSigner.ts","../src/NaclSigner.ts"],"sourcesContent":["import { sha256 as sha256js, Message } from 'js-sha256'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\nimport { Buffer } from 'buffer'\n\nexport function sha256(payload: Message): Buffer {\n  return Buffer.from(sha256js.arrayBuffer(payload))\n}\n\nexport function keccak(data: Message): Buffer {\n  return Buffer.from(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress(hexPublicKey: string): string {\n  return `0x${keccak(Buffer.from(hexPublicKey.slice(2), 'hex'))\n    .slice(-20)\n    .toString('hex')}`\n}\n","import { ec as EC, ec } from 'elliptic'\nimport { sha256 } from './Digest'\nimport { Signer } from './JWT'\n\nconst secp256k1: EC = new EC('secp256k1')\n\nfunction leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n/**\n *  The SimpleSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  if (hexPrivateKey.startsWith('0x')) {\n    hexPrivateKey = hexPrivateKey.substring(2)\n  }\n  const privateKey: ec.KeyPair = secp256k1.keyFromPrivate(hexPrivateKey)\n  return async data => {\n    const { r, s, recoveryParam }: EC.Signature = privateKey.sign(sha256(data))\n    return {\n      r: leftpad(r.toString('hex')),\n      s: leftpad(s.toString('hex')),\n      recoveryParam\n    }\n  }\n}\n\nexport default SimpleSigner\n","import { EcdsaSignature } from './JWT'\nimport base64url from 'uport-base64url'\n\nexport function base64ToBytes(s: string): Uint8Array {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0))\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return Buffer.from(b).toString('base64')\n}\n\nexport function toJose({ r, s, recoveryParam }: EcdsaSignature, recoverable?: boolean): string {\n  const jose: Buffer = Buffer.alloc(recoverable ? 65 : 64)\n  Buffer.from(r, 'hex').copy(jose, 0)\n  Buffer.from(s, 'hex').copy(jose, 32)\n  if (recoverable) {\n    if (recoveryParam === undefined) {\n      throw new Error('Signer did not return a recoveryParam')\n    }\n    jose[64] = recoveryParam\n  }\n  return base64url.encode(jose)\n}\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport base64url from 'uport-base64url'\nimport { verify } from '@stablelib/ed25519'\nimport { EcdsaSignature } from './JWT'\nimport { PublicKey } from 'did-resolver'\nimport { encode } from '@stablelib/utf8'\nimport { base64ToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(signature: string, recoverable = false): EcdsaSignature {\n  const rawsig: Buffer = base64url.toBuffer(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = rawsig.slice(0, 32).toString('hex')\n  const s: string = rawsig.slice(32, 64).toString('hex')\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\nexport function verifyES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const hash: Buffer = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const fullPublicKeys = authenticators.filter(({ publicKeyHex }) => {\n    return typeof publicKeyHex !== 'undefined'\n  })\n  const ethAddressKeys = authenticators.filter(({ ethereumAddress }) => {\n    return typeof ethereumAddress !== 'undefined'\n  })\n\n  let signer: PublicKey = fullPublicKeys.find(({ publicKeyHex }) => {\n    try {\n      return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj)\n    } catch (err) {\n      return false\n    }\n  })\n\n  if (!signer && ethAddressKeys.length > 0) {\n    signer = verifyRecoverableES256K(data, signature, ethAddressKeys)\n  }\n\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  let signatures: EcdsaSignature[]\n  if (signature.length > 86) {\n    signatures = [toSignatureObject(signature, true)]\n  } else {\n    const so = toSignatureObject(signature, false)\n    signatures = [\n      { ...so, recoveryParam: 0 },\n      { ...so, recoveryParam: 1 }\n    ]\n  }\n\n  const checkSignatureAgainstSigner = (sigObj: EcdsaSignature): PublicKey => {\n    const hash: Buffer = sha256(data)\n    const recoveredKey: any = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam)\n    const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n    const recoveredCompressedPublicKeyHex: string = recoveredKey.encode('hex', true)\n    const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n\n    const signer: PublicKey = authenticators.find(\n      ({ publicKeyHex, ethereumAddress }) =>\n        publicKeyHex === recoveredPublicKeyHex ||\n        publicKeyHex === recoveredCompressedPublicKeyHex ||\n        ethereumAddress === recoveredAddress\n    )\n\n    return signer\n  }\n\n  const signer: PublicKey[] = signatures.map(checkSignatureAgainstSigner).filter(key => key != null)\n\n  if (signer.length === 0) throw new Error('Signature invalid for JWT')\n  return signer[0]\n}\n\nexport function verifyEd25519(data: string, signature: string, authenticators: PublicKey[]): PublicKey {\n  const clear: Uint8Array = encode(data)\n  const sig: Uint8Array = base64ToBytes(base64url.toBase64(signature))\n  const signer: PublicKey = authenticators.find(({ publicKeyBase64 }) =>\n    verify(base64ToBytes(publicKeyBase64), clear, sig)\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (data: string, signature: string, authenticators: PublicKey[]) => PublicKey\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  Ed25519: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import { Buffer } from 'buffer'\nimport { Signer, EcdsaSignature, SignerAlgorithm } from './JWT'\nimport { toJose } from './util'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSigner(recoverable?: boolean): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature, recoverable)\n    } else {\n      if (recoverable) throw new Error('ES256K-R not supported when signer function returns string')\n      return signature\n    }\n  }\n}\n\nexport function Ed25519Signer(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error('expected a signer function that returns a string instead of signature object')\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSigner(),\n  'ES256K-R': ES256KSigner(true),\n  Ed25519: Ed25519Signer()\n}\n\nfunction SignerAlgorithm(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlgorithm\n","import VerifierAlgorithm from './VerifierAlgorithm'\nimport SignerAlgorithm from './SignerAlgorithm'\nimport base64url from 'uport-base64url'\nimport { DIDDocument, PublicKey } from 'did-resolver'\n\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport type Signer = (data: string) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (payload: string, signer: Signer) => Promise<string>\n\nexport interface JWTOptions {\n  issuer: string\n  signer: Signer\n  alg?: string\n  expiresIn?: number\n}\n\nexport interface Resolvable {\n  resolve: (did: string) => Promise<DIDDocument | null>\n}\n\nexport interface JWTVerifyOptions {\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n  resolver?: Resolvable\n}\n\nexport interface DIDAuthenticator {\n  authenticators: PublicKey[]\n  issuer: string\n  doc: DIDDocument\n}\n\nexport interface JWTHeader {\n  typ: 'JWT'\n  alg: string\n  [x: string]: any\n}\n\nexport interface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string | string[]\n  iat?: number\n  nbf?: number\n  type?: string\n  exp?: number\n  rexp?: number\n  [x: string]: any\n}\n\nexport interface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\nexport interface JWSDecoded {\n  header: JWTHeader\n  payload: string\n  signature: string\n  data: string\n}\n\nexport interface JWTVerified {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: object\n  jwt: string\n}\n\nexport interface PublicKeyTypes {\n  [name: string]: string[]\n}\nexport const SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  Ed25519: ['ED25519SignatureVerification']\n}\n\nconst defaultAlg = 'ES256K'\n\nfunction encodeSection(data: any): string {\n  return base64url.encode(JSON.stringify(data))\n}\n\nexport const NBF_SKEW: number = 300\n\nfunction decodeJWS(jws: string): JWSDecoded {\n  const parts: RegExpMatchArray = jws.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/)\n  if (parts) {\n    return {\n      header: JSON.parse(base64url.decode(parts[1])),\n      payload: parts[2],\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWS')\n}\n\n/**  @module did-jwt/JWT */\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  try {\n    const jws = decodeJWS(jwt)\n    const decodedJwt: JWTDecoded = Object.assign(jws, { payload: JSON.parse(base64url.decode(jws.payload)) })\n    return decodedJwt\n  } catch(e) {\n    throw new Error('Incorrect format JWT')\n  }\n}\n\n/**\n *  Creates a signed JWS given a payload, a signer, and an optional header.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  const jws = await createJWS({ my: 'payload' }, signer)\n *\n *  @param    {Object}            payload           payload object\n *  @param    {SimpleSigner}      signer            a signer, reference our SimpleSigner.js\n *  @param    {Object}            header            optional object to specify or customize the JWS header\n *  @return   {Promise<Object, Error>}              a promise which resolves with a JWS string or rejects with an error\n */\nexport async function createJWS(payload: string | any, signer: Signer, header: Partial<JWTHeader> = {}): Promise<string> {\n  if (!header.alg) header.alg = defaultAlg\n  const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload)\n  const signingInput: string = [encodeSection(header), encodedPayload].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlgorithm(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload            payload object\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg         [DEPRECATED] The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K.\n *                                                    Please use `header.alg` to specify the algorithm\n *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js\n *  @param    {Object}            header             optional object to specify or customize the JWT header\n *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n */\nexport async function createJWT(\n  payload: any,\n  { issuer, signer, alg, expiresIn }: JWTOptions,\n  header: Partial<JWTHeader> = {}\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  if (!header.typ) header.typ = 'JWT'\n  if (!header.alg) header.alg = alg\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = (payload.nbf || timestamps.iat) + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const fullPayload = { ...timestamps, ...payload, iss: issuer }\n  return createJWS(fullPayload, signer, header)\n}\n\nfunction verifyJWSDecoded({ header, data, signature }: JWSDecoded, pubkeys: PublicKey | PublicKey[]): PublicKey {\n  if (!Array.isArray(pubkeys)) pubkeys = [pubkeys]\n  const signer: PublicKey = VerifierAlgorithm(header.alg)(data, signature, pubkeys)\n  return signer\n}\n\n/**\n *  Verifies given JWS. If the JWS is valid, returns the public key that was\n *  used to sign the JWS, or throws an `Error` if none of the `pubkeys` match.\n *\n *  @example\n *  const pubkey = verifyJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', { publicKeyHex: '0x12341...' })\n *\n *  @param    {String}                          jws         A JWS string to verify\n *  @param    {Array<PublicKey> | PublicKey}    pubkeys     The public keys used to verify the JWS\n *  @return   {PublicKey}                       The public key used to sign the JWS\n */\nexport function verifyJWS(jws: string, pubkeys: PublicKey | PublicKey[]): PublicKey {\n  const jwsDecoded: JWSDecoded = decodeJWS(jws)\n  return verifyJWSDecoded(jwsDecoded, pubkeys)\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = {\n    resolver: null,\n    auth: null,\n    audience: null,\n    callbackUrl: null\n  }\n): Promise<JWTVerified> {\n  if (!options.resolver) throw new Error('No DID resolver has been configured')\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const { doc, authenticators, issuer }: DIDAuthenticator = await resolveAuthenticator(\n    options.resolver,\n    header.alg,\n    payload.iss,\n    options.auth\n  )\n  const signer: PublicKey = await verifyJWSDecoded({ header, data, signature } as JWSDecoded, authenticators)\n  const now: number = Math.floor(Date.now() / 1000)\n  if (signer) {\n    const nowSkewed = now + NBF_SKEW\n    if (payload.nbf) {\n      if (payload.nbf > nowSkewed) {\n        throw new Error(`JWT not valid before nbf: ${payload.nbf}`)\n      }\n    } else if (payload.iat && payload.iat > nowSkewed) {\n      throw new Error(`JWT not valid yet (issued in the future) iat: ${payload.iat}`)\n    }\n    if (payload.exp && payload.exp <= now - NBF_SKEW) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (!options.audience && !options.callbackUrl) {\n        throw new Error('JWT audience is required but your app address has not been configured')\n      }\n      const audArray = Array.isArray(payload.aud) ? payload.aud : [payload.aud]\n      const matchedAudience = audArray.find(item => options.audience === item || options.callbackUrl === item)\n\n      if (typeof matchedAudience === 'undefined') {\n        throw new Error(`JWT audience does not match your DID or callback url`)\n      }\n    }\n    return { payload, doc, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator(resolver, 'ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  resolver: Resolvable,\n  alg: string,\n  issuer: string,\n  auth?: boolean\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  const doc: DIDDocument = await resolver.resolve(issuer)\n  if (!doc) throw new Error(`Unable to resolve DID document for ${issuer}`)\n  // is there some way to have authenticationKeys be a single type?\n  const authenticationKeys: boolean | string[] = auth\n    ? (doc.authentication || []).map(({ publicKey }) => publicKey)\n    : true\n  const authenticators: PublicKey[] = (doc.publicKey || []).filter(({ type, id }) =>\n    types.find(\n      supported =>\n        supported === type && (!auth || (Array.isArray(authenticationKeys) && authenticationKeys.indexOf(id) >= 0))\n    )\n  )\n\n  if (auth && (!authenticators || authenticators.length === 0)) {\n    throw new Error(`DID document for ${issuer} does not have public keys suitable for authenticationg user`)\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(`DID document for ${issuer} does not have public keys for ${alg}`)\n  }\n  return { authenticators, issuer, doc }\n}\n","import { EcdsaSignature } from './JWT'\nimport SimpleSigner from './SimpleSigner'\nimport { toJose } from './util'\n\ntype Signer = (data: string) => Promise<string>\n// we know that we always get a EcdsaSignature from Simplesigner\nconst isEcdsaSig = (obj: any): obj is EcdsaSignature => true\n\n/**\n *  The EllipticSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = EllipticSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                        a configured signer function\n */\nfunction EllipticSigner(hexPrivateKey: string): Signer {\n  const signer = SimpleSigner(hexPrivateKey)\n  return async data => {\n    const signature: EcdsaSignature | string = await signer(data)\n    if (isEcdsaSig(signature)) {\n      return toJose(signature)\n    }\n  }\n}\n\nexport default EllipticSigner\n","import { sign } from '@stablelib/ed25519'\nimport { encode } from '@stablelib/utf8'\nimport { Buffer } from 'buffer'\nimport { Signer } from './JWT'\nimport { base64ToBytes } from './util'\nimport base64url from 'uport-base64url'\n\n/**\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  const privateKey: Uint8Array = base64ToBytes(base64PrivateKey)\n  return async data => {\n    const dataBytes: Uint8Array = encode(data)\n    const sig: Uint8Array = sign(privateKey, dataBytes)\n    const b64UrlSig: string = base64url.encode(Buffer.from(sig))\n    return b64UrlSig\n  }\n}\n\nexport default NaclSigner\n"],"names":["sha256","payload","Buffer","from","sha256js","arrayBuffer","toEthereumAddress","hexPublicKey","data","slice","keccak_256","toString","secp256k1","EC","leftpad","size","length","repeat","SimpleSigner","hexPrivateKey","startsWith","substring","privateKey","keyFromPrivate","sign","s","recoveryParam","r","base64ToBytes","Uint8Array","Array","prototype","call","toJose","recoverable","jose","alloc","copy","undefined","Error","base64url","encode","toSignatureObject","signature","rawsig","toBuffer","sigObj","verifyRecoverableES256K","authenticators","signatures","so","signer","map","hash","recoveredKey","recoverPubKey","recoveredPublicKeyHex","recoveredCompressedPublicKeyHex","recoveredAddress","find","publicKeyHex","ethereumAddress","filter","key","algorithms","ES256K","fullPublicKeys","ethAddressKeys","keyFromPublic","verify","err","ES256K-R","Ed25519","clear","sig","toBase64","publicKeyBase64","VerifierAlgorithm","alg","impl","instanceOfEcdsaSignature","object","ES256KSigner","createJWS","header","defaultAlg","encodedPayload","encodeSection","signingInput","join","jwtSigner","SignerAlgorithm","SUPPORTED_PUBLIC_KEY_TYPES","JSON","stringify","decodeJWS","jws","parts","match","parse","decode","decodeJWT","jwt","Object","assign","e","verifyJWSDecoded","pubkeys","isArray","base64PrivateKey","dataBytes","b64UrlSig","issuer","expiresIn","typ","timestamps","iat","Math","floor","Date","now","exp","nbf","fullPayload","iss","options","resolver","auth","audience","callbackUrl","types","resolve","doc","authenticationKeys","authentication","publicKey","type","id","supported","indexOf","resolveAuthenticator","nowSkewed","aud","item"],"mappings":"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"}