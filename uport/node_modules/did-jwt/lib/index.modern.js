import{ec as r}from"elliptic";import{sha256 as e}from"js-sha256";import{keccak_256 as n}from"js-sha3";import{Buffer as t}from"buffer";import o from"uport-base64url";import{sign as i,verify as a}from"@stablelib/ed25519";import{encode as c}from"@stablelib/utf8";function u(r){return t.from(e.arrayBuffer(r))}function s(r){return"0x"+(e=t.from(r.slice(2),"hex"),t.from(n.arrayBuffer(e))).slice(-20).toString("hex");var e}const f=new r("secp256k1");function l(r,e=64){return r.length===e?r:"0".repeat(e-r.length)+r}function d(r){r.startsWith("0x")&&(r=r.substring(2));const e=f.keyFromPrivate(r);return async r=>{const{r:n,s:t,recoveryParam:o}=e.sign(u(r));return{r:l(n.toString("hex")),s:l(t.toString("hex")),recoveryParam:o}}}function h(r){return new Uint8Array(Array.prototype.slice.call(Buffer.from(r,"base64"),0))}function p({r,s:e,recoveryParam:n},t){const i=Buffer.alloc(t?65:64);if(Buffer.from(r,"hex").copy(i,0),Buffer.from(e,"hex").copy(i,32),t){if(void 0===n)throw new Error("Signer did not return a recoveryParam");i[64]=n}return o.encode(i)}function y(r){const e=d(r);return async r=>p(await e(r))}function w(r){const e=h(r);return async r=>{const n=c(r),a=i(e,n);return o.encode(t.from(a))}}const g=new r("secp256k1");function m(r,e=!1){const n=o.toBuffer(r);if(n.length!==(e?65:64))throw new Error("wrong signature length");const t={r:n.slice(0,32).toString("hex"),s:n.slice(32,64).toString("hex")};return e&&(t.recoveryParam=n[64]),t}function b(r,e,n){let t;if(e.length>86)t=[m(e,!0)];else{const r=m(e,!1);t=[{...r,recoveryParam:0},{...r,recoveryParam:1}]}const o=t.map(e=>{const t=u(r),o=g.recoverPubKey(t,e,e.recoveryParam),i=o.encode("hex"),a=o.encode("hex",!0),c=s(i);return n.find(({publicKeyHex:r,ethereumAddress:e})=>r===i||r===a||e===c)}).filter(r=>null!=r);if(0===o.length)throw new Error("Signature invalid for JWT");return o[0]}const E={ES256K:function(r,e,n){const t=u(r),o=m(e),i=n.filter(({publicKeyHex:r})=>void 0!==r),a=n.filter(({ethereumAddress:r})=>void 0!==r);let c=i.find(({publicKeyHex:r})=>{try{return g.keyFromPublic(r,"hex").verify(t,o)}catch(r){return!1}});if(!c&&a.length>0&&(c=b(r,e,a)),!c)throw new Error("Signature invalid for JWT");return c},"ES256K-R":b,Ed25519:function(r,e,n){const t=c(r),i=h(o.toBase64(e)),u=n.find(({publicKeyBase64:r})=>a(h(r),t,i));if(!u)throw new Error("Signature invalid for JWT");return u}};function S(r){const e=E[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}function v(r){return"object"==typeof r&&"r"in r&&"s"in r}function x(r){return async function(e,n){const t=await n(e);if(v(t))return p(t,r);if(r)throw new Error("ES256K-R not supported when signer function returns string");return t}}S.toSignatureObject=m;const K={ES256K:x(),"ES256K-R":x(!0),Ed25519:async function(r,e){const n=await e(r);if(v(n))throw new Error("expected a signer function that returns a string instead of signature object");return n}},J={ES256K:["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],"ES256K-R":["Secp256k1VerificationKey2018","Secp256k1SignatureVerificationKey2018","EcdsaPublicKeySecp256k1"],Ed25519:["ED25519SignatureVerification"]};function k(r){return o.encode(JSON.stringify(r))}function D(r){const e=r.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);if(e)return{header:JSON.parse(o.decode(e[1])),payload:e[2],signature:e[3],data:`${e[1]}.${e[2]}`};throw new Error("Incorrect format JWS")}function W(r){if(!r)throw new Error("no JWT passed into decodeJWT");try{const e=D(r);return Object.assign(e,{payload:JSON.parse(o.decode(e.payload))})}catch(r){throw new Error("Incorrect format JWT")}}async function A(r,e,n={}){n.alg||(n.alg="ES256K");const t="string"==typeof r?r:k(r),o=[k(n),t].join("."),i=function(r){const e=K[r];if(!e)throw new Error("Unsupported algorithm "+r);return e}(n.alg);return[o,await i(o,e)].join(".")}async function P(r,{issuer:e,signer:n,alg:t,expiresIn:o},i={}){if(!n)throw new Error("No Signer functionality has been configured");if(!e)throw new Error("No issuing DID has been configured");i.typ||(i.typ="JWT"),i.alg||(i.alg=t);const a={iat:Math.floor(Date.now()/1e3),exp:void 0};if(o){if("number"!=typeof o)throw new Error("JWT expiresIn is not a number");a.exp=(r.nbf||a.iat)+Math.floor(o)}return A({...a,...r,iss:e},n,i)}function T({header:r,data:e,signature:n},t){return Array.isArray(t)||(t=[t]),S(r.alg)(e,n,t)}function B(r,e){return T(D(r),e)}async function I(r,e={resolver:null,auth:null,audience:null,callbackUrl:null}){if(!e.resolver)throw new Error("No DID resolver has been configured");const{payload:n,header:t,signature:o,data:i}=W(r),{doc:a,authenticators:c,issuer:u}=await async function(r,e,n,t){const o=J[e];if(!o||0===o.length)throw new Error("No supported signature types for algorithm "+e);const i=await r.resolve(n);if(!i)throw new Error("Unable to resolve DID document for "+n);const a=!t||(i.authentication||[]).map(({publicKey:r})=>r),c=(i.publicKey||[]).filter(({type:r,id:e})=>o.find(n=>n===r&&(!t||Array.isArray(a)&&a.indexOf(e)>=0)));if(t&&(!c||0===c.length))throw new Error(`DID document for ${n} does not have public keys suitable for authenticationg user`);if(!c||0===c.length)throw new Error(`DID document for ${n} does not have public keys for ${e}`);return{authenticators:c,issuer:n,doc:i}}(e.resolver,t.alg,n.iss,e.auth),s=await T({header:t,data:i,signature:o},c),f=Math.floor(Date.now()/1e3);if(s){const t=f+300;if(n.nbf){if(n.nbf>t)throw new Error("JWT not valid before nbf: "+n.nbf)}else if(n.iat&&n.iat>t)throw new Error("JWT not valid yet (issued in the future) iat: "+n.iat);if(n.exp&&n.exp<=f-300)throw new Error(`JWT has expired: exp: ${n.exp} < now: ${f}`);if(n.aud){if(!e.audience&&!e.callbackUrl)throw new Error("JWT audience is required but your app address has not been configured");if(void 0===(Array.isArray(n.aud)?n.aud:[n.aud]).find(r=>e.audience===r||e.callbackUrl===r))throw new Error("JWT audience does not match your DID or callback url")}return{payload:n,doc:a,issuer:u,signer:s,jwt:r}}}export{y as EllipticSigner,w as NaclSigner,d as SimpleSigner,A as createJWS,P as createJWT,W as decodeJWT,s as toEthereumAddress,B as verifyJWS,I as verifyJWT};
//# sourceMappingURL=index.modern.js.map
