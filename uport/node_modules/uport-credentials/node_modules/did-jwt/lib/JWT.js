"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeDID = normalizeDID;
exports.decodeJWT = decodeJWT;
exports.createJWT = createJWT;
exports.verifyJWT = verifyJWT;
exports.resolveAuthenticator = resolveAuthenticator;
exports.default = exports.IAT_SKEW = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _VerifierAlgorithm = _interopRequireDefault(require("./VerifierAlgorithm"));

var _SignerAlgorithm = _interopRequireDefault(require("./SignerAlgorithm"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = _interopRequireDefault(require("did-resolver"));

var SUPPORTED_PUBLIC_KEY_TYPES = {
  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],
  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],
  'Ed25519': ['ED25519SignatureVerification']
};
var JOSE_HEADER = {
  typ: 'JWT'
};
var defaultAlg = 'ES256K';

function encodeSection(data) {
  return _base64url.default.encode(JSON.stringify(data));
}

var IAT_SKEW = 300;
/**  @module did-jwt/JWT */

exports.IAT_SKEW = IAT_SKEW;

function isMNID(id) {
  return id.match(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/);
}

function isDIDOrMNID(mnidOrDid) {
  return mnidOrDid && (mnidOrDid.match(/^did:/) || isMNID(mnidOrDid));
}

function normalizeDID(mnidOrDid) {
  if (mnidOrDid.match(/^did:/)) return mnidOrDid; // Backwards compatibility

  if (isMNID(mnidOrDid)) return "did:uport:".concat(mnidOrDid);
  throw new Error("Not a valid DID '".concat(mnidOrDid, "'"));
}
/**
*  Decodes a JWT and returns an object representing the payload
*
*  @example
*  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1MjU5Mjc1MTcsImF1ZCI6ImRpZDp1cG9ydDoyb3NuZko0V3k3TEJBbTJuUEJYaXJlMVdmUW43NVJyVjZUcyIsImV4cCI6MTU1NzQ2MzQyMSwibmFtZSI6InVQb3J0IERldmVsb3BlciIsImlzcyI6ImRpZDp1cG9ydDoyb3NuZko0V3k3TEJBbTJuUEJYaXJlMVdmUW43NVJyVjZUcyJ9.R7owbvNZoL4ti5ec-Kpktb0datw9Y-FshHsF5R7cXuKaiGlQz1dcOOXbXTOb-wg7-30CDfchFERR6Yc8F61ymw')
*
*  @param    {String}            jwt                a JSON Web Token to verify
*  @return   {Object}                               a JS object representing the decoded JWT
*/


function decodeJWT(jwt) {
  if (!jwt) throw new Error('no JWT passed into decodeJWT');
  var parts = jwt.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);

  if (parts) {
    return {
      header: JSON.parse(_base64url.default.decode(parts[1])),
      payload: JSON.parse(_base64url.default.decode(parts[2])),
      signature: parts[3],
      data: "".concat(parts[1], ".").concat(parts[2])
    };
  }

  throw new Error('Incorrect format JWT');
}
/**
*  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.
*
*  @example
*  const signer = SimpleSigner(process.env.PRIVATE_KEY)
*  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {
*      ...
*  })
*
*  @param    {Object}            payload            payload object
*  @param    {Object}            [options]           an unsigned credential object
*  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT
*  @param    {String}            options.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K
*  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js
*  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error
*/


function createJWT(_x, _x2) {
  return _createJWT.apply(this, arguments);
}
/**
*  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,
*  and the did doc of the issuer of the JWT.
*
*  @example
*  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {
*      const did = obj.did // DID of signer
*      const payload = obj.payload
*      const doc = obj.doc // DID Document of signer
*      const jwt = obj.jwt
*      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT
*      ...
*  })
*
*  @param    {String}            jwt                a JSON Web Token to verify
*  @param    {Object}            [options]           an unsigned credential object
*  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)
*  @param    {String}            options.audience    DID of the recipient of the JWT
*  @param    {String}            options.callbackUrl callback url in JWT
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error
*/


function _createJWT() {
  _createJWT = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(payload, _ref) {
    var issuer, signer, alg, expiresIn, header, timestamps, signingInput, jwtSigner, signature;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            issuer = _ref.issuer, signer = _ref.signer, alg = _ref.alg, expiresIn = _ref.expiresIn;

            if (signer) {
              _context.next = 3;
              break;
            }

            throw new Error('No Signer functionality has been configured');

          case 3:
            if (issuer) {
              _context.next = 5;
              break;
            }

            throw new Error('No issuing DID has been configured');

          case 5:
            header = (0, _objectSpread2.default)({}, JOSE_HEADER, {
              alg: alg || defaultAlg
            });
            timestamps = {
              iat: Math.floor(Date.now() / 1000)
            };

            if (!expiresIn) {
              _context.next = 13;
              break;
            }

            if (!(typeof expiresIn === 'number')) {
              _context.next = 12;
              break;
            }

            timestamps.exp = timestamps.iat + Math.floor(expiresIn);
            _context.next = 13;
            break;

          case 12:
            throw new Error('JWT expiresIn is not a number');

          case 13:
            signingInput = [encodeSection(header), encodeSection((0, _objectSpread2.default)({}, timestamps, payload, {
              iss: issuer
            }))].join('.');
            jwtSigner = (0, _SignerAlgorithm.default)(header.alg);
            _context.next = 17;
            return jwtSigner(signingInput, signer);

          case 17:
            signature = _context.sent;
            return _context.abrupt("return", [signingInput, signature].join('.'));

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _createJWT.apply(this, arguments);
}

function verifyJWT(_x3) {
  return _verifyJWT.apply(this, arguments);
}
/**
* Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID
*
*  @example
*  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {
*      const payload = obj.payload
*      const profile = obj.profile
*      const jwt = obj.jwt
*      ...
*  })
*
*  @param    {String}            alg                a JWT algorithm
*  @param    {String}            did                a Decentralized IDentifier (DID) to lookup
*  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error
*/


function _verifyJWT() {
  _verifyJWT = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(jwt) {
    var options,
        aud,
        _decodeJWT,
        payload,
        header,
        signature,
        data,
        _ref2,
        doc,
        authenticators,
        issuer,
        signer,
        now,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
            aud = options.audience ? normalizeDID(options.audience) : undefined;
            _decodeJWT = decodeJWT(jwt), payload = _decodeJWT.payload, header = _decodeJWT.header, signature = _decodeJWT.signature, data = _decodeJWT.data;
            _context2.next = 5;
            return resolveAuthenticator(header.alg, payload.iss, options.auth);

          case 5:
            _ref2 = _context2.sent;
            doc = _ref2.doc;
            authenticators = _ref2.authenticators;
            issuer = _ref2.issuer;
            signer = (0, _VerifierAlgorithm.default)(header.alg)(data, signature, authenticators);
            now = Math.floor(Date.now() / 1000);

            if (!signer) {
              _context2.next = 31;
              break;
            }

            if (!(payload.iat && payload.iat > now + IAT_SKEW)) {
              _context2.next = 14;
              break;
            }

            throw new Error("JWT not valid yet (issued in the future): iat: ".concat(payload.iat, " > now: ").concat(now));

          case 14:
            if (!(payload.exp && payload.exp <= now - IAT_SKEW)) {
              _context2.next = 16;
              break;
            }

            throw new Error("JWT has expired: exp: ".concat(payload.exp, " < now: ").concat(now));

          case 16:
            if (!payload.aud) {
              _context2.next = 28;
              break;
            }

            if (!isDIDOrMNID(payload.aud)) {
              _context2.next = 24;
              break;
            }

            if (aud) {
              _context2.next = 20;
              break;
            }

            throw new Error('JWT audience is required but your app address has not been configured');

          case 20:
            if (!(aud !== normalizeDID(payload.aud))) {
              _context2.next = 22;
              break;
            }

            throw new Error("JWT audience does not match your DID: aud: ".concat(payload.aud, " !== yours: ").concat(aud));

          case 22:
            _context2.next = 28;
            break;

          case 24:
            if (options.callbackUrl) {
              _context2.next = 26;
              break;
            }

            throw new Error('JWT audience matching your callback url is required but one wasn\'t passed in');

          case 26:
            if (!(payload.aud !== options.callbackUrl)) {
              _context2.next = 28;
              break;
            }

            throw new Error("JWT audience does not match the callback url: aud: ".concat(payload.aud, " !== url: ").concat(options.callbackUrl));

          case 28:
            return _context2.abrupt("return", {
              payload: payload,
              doc: doc,
              issuer: issuer,
              signer: signer,
              jwt: jwt
            });

          case 31:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _verifyJWT.apply(this, arguments);
}

function resolveAuthenticator(_x4, _x5, _x6) {
  return _resolveAuthenticator.apply(this, arguments);
}

function _resolveAuthenticator() {
  _resolveAuthenticator = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3(alg, mnidOrDid, auth) {
    var types, issuer, doc, authenticationKeys, authenticators;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            types = SUPPORTED_PUBLIC_KEY_TYPES[alg];

            if (!(!types || types.length === 0)) {
              _context3.next = 3;
              break;
            }

            throw new Error("No supported signature types for algorithm ".concat(alg));

          case 3:
            issuer = normalizeDID(mnidOrDid);
            _context3.next = 6;
            return (0, _didResolver.default)(issuer);

          case 6:
            doc = _context3.sent;

            if (doc) {
              _context3.next = 9;
              break;
            }

            throw new Error("Unable to resolve DID document for ".concat(issuer));

          case 9:
            authenticationKeys = auth ? (doc.authentication || []).map(function (_ref3) {
              var publicKey = _ref3.publicKey;
              return publicKey;
            }) : true;
            authenticators = (doc.publicKey || []).filter(function (_ref4) {
              var type = _ref4.type,
                  id = _ref4.id;
              return types.find(function (supported) {
                return supported === type && (!auth || authenticationKeys.indexOf(id) >= 0);
              });
            });

            if (!(auth && (!authenticators || authenticators.length === 0))) {
              _context3.next = 13;
              break;
            }

            throw new Error("DID document for ".concat(issuer, " does not have public keys suitable for authenticationg user"));

          case 13:
            if (!(!authenticators || authenticators.length === 0)) {
              _context3.next = 15;
              break;
            }

            throw new Error("DID document for ".concat(issuer, " does not have public keys for ").concat(alg));

          case 15:
            return _context3.abrupt("return", {
              authenticators: authenticators,
              issuer: issuer,
              doc: doc
            });

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _resolveAuthenticator.apply(this, arguments);
}

var _default = {
  decodeJWT: decodeJWT,
  createJWT: createJWT,
  verifyJWT: verifyJWT,
  resolveAuthenticator: resolveAuthenticator
};
exports.default = _default;